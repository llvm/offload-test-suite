#--- source.hlsl

// This test checks that we will get the expected values from invoking
// various `Load` and `Store` methods on `[RW]ByteAddressBuffer`.

// The expected behaviour is to load the values in `In0` and `In1` at the given
// byte-offset, add them, and store the result at the respective offset in
// `Out`. We expect each load and store to only access mapped resource data, so
// `CheckAccessFullyMapped` should always return `true = 1`.

struct S0 {
  int a;
  uint b;
};

struct S1 {
  int4 a;
  int4 b;
  uint4 c;
  uint4 d;
};

ByteAddressBuffer In0 : register(t0);
ByteAddressBuffer In1 : register(t1);
RWByteAddressBuffer Out : register(u0);
RWBuffer<uint> Mapped : register(u0, space1);

[numthreads(4,1,1)]
void main() {
  uint status;

  // uint
  uint U0 = In0.Load(0, status);
  Mapped[0] = CheckAccessFullyMapped(status);
  uint V0 = In1.Load(0);
  Out.Store(0, U0 + V0);

  uint2 U1 = In0.Load2(16, status);
  Mapped[1] = CheckAccessFullyMapped(status);
  uint2 V1 = In1.Load2(16);
  Out.Store2(16, U1 + V1);

  uint3 U2 = In0.Load3(32, status);
  Mapped[2] = CheckAccessFullyMapped(status);
  uint3 V2 = In1.Load3(32);
  Out.Store3(32, U2 + V2);

  uint4 U3 = In0.Load4(48, status);
  Mapped[3] = CheckAccessFullyMapped(status);
  uint4 V3 = In1.Load4(48);
  Out.Store4(48, U3 + V3);

  // bool
  bool U4 = In0.Load<bool>(64, status);
  Mapped[4] = CheckAccessFullyMapped(status);
  bool V4 = In1.Load<bool>(64);
  Out.Store<bool>(64, U4 + V4);

  bool2 U5 = In0.Load<bool2>(64, status);
  Mapped[5] = CheckAccessFullyMapped(status);
  bool2 V5 = In1.Load<bool2>(64);
  Out.Store<bool2>(80, U5 + V5);

  bool3 U6 = In0.Load<bool3>(64, status);
  Mapped[6] = CheckAccessFullyMapped(status);
  bool3 V6 = In1.Load<bool3>(64);
  Out.Store<bool3>(96, U6 + V6);

  bool4 U7 = In0.Load<bool4>(64, status);
  Mapped[7] = CheckAccessFullyMapped(status);
  bool4 V7 = In1.Load<bool4>(64);
  Out.Store<bool4>(112, U7 + V7);

  // array
  int U8[4] = In0.Load<int[4]>(0, status);
  Mapped[8] = CheckAccessFullyMapped(status);
  int V8[4] = In1.Load<int[4]>(0);
  int TempArray[4];
  for(int i = 0; i < 4; i++) {
    TempArray[i] = U8[i] + V8[i];
  }
  Out.Store<int[4]>(128, TempArray);

  // structs
  S0 U9 = In0.Load<S0>(0, status);
  Mapped[9] = CheckAccessFullyMapped(status);
  S0 V9 = In1.Load<S0>(0);
  S0 TempStruct0 = {U9.a + V9.a, U9.b + V9.b};
  Out.Store<S0>(144, TempStruct0);

  S1 U10 = In0.Load<S1>(0, status);
  Mapped[10] = CheckAccessFullyMapped(status);
  S1 V10 = In1.Load<S1>(0);
  S1 TempStruct1 = {U10.a + V10.a, U10.b + V10.b, U10.c + V10.c, U10.d + V10.d};
  Out.Store<S1>(160, TempStruct1);
}

//--- pipeline.yaml

---
Shaders:
  - Stage: Compute
    Entry: main
    DispatchSize: [4, 1, 1]
Buffers:
  - Name: In0
    Format: Int32
    Stride: 4
    Data: [ 1, 2, 3, 4, 5, 6, 7, 8, 
            9, 10, 11, 12, 13, 14, 15, 16,
            1, 0, 1, 0 ]
  - Name: In1
    Format: Hex32
    Stride: 4
    Data: [ 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 
            0x900, 0xA00, 0xB00, 0xC00, 0xD00, 0xE00, 0xF00, 0x1000,
            0x001, 0x000, 0x000, 0x001 ]
  - Name: Out
    Format: Hex32
    Stride: 4
    FillSize: 224
  - Name: ExpectedOut
    Format: Hex32
    Stride: 4
    Data: [ 0x101, 0x000, 0x000, 0x000, 0x505, 0x606, 0x000, 0x000,
            0x909, 0xA0A, 0xB0B, 0x000, 0xD0D, 0xE0E, 0xF0F, 0x1010,
            0x001, 0x000, 0x000, 0x000, 0x001, 0x000, 0x000, 0x000,
            0x001, 0x000, 0x001, 0x000, 0x001, 0x000, 0x001, 0x001,
            0x101, 0x202, 0x303, 0x404, 0x101, 0x202, 0x000, 0x000,
            0x101, 0x202, 0x303, 0x404, 0x505, 0x606, 0x707, 0x808,
            0x909, 0xA0A, 0xB0B, 0xC0C, 0xD0D, 0xE0E, 0xF0F, 0x1010 ]
  - Name: Mapped
    Format: Int32
    Stride: 4
    FillSize: 44
  - Name: ExpectedMapped
    Format: Int32
    Stride: 4
    Data: [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
Results:
  - Result: Test0
    Rule: BufferExact
    Actual: Out
    Expected: ExpectedOut
  - Result: Test1
    Rule: BufferExact
    Actual: Mapped
    Expected: ExpectedMapped
DescriptorSets:
  - Resources:
    - Name: In0
      Kind: ByteAddressBuffer
      DirectXBinding:
        Register: 0
        Space: 0
    - Name: In1
      Kind: ByteAddressBuffer
      DirectXBinding:
        Register: 1
        Space: 0
    - Name: Out
      Kind: RWByteAddressBuffer
      DirectXBinding:
        Register: 0
        Space: 0
    - Name: Mapped
      Kind: RWBuffer
      DirectXBinding:
        Register: 0
        Space: 1
...
#--- end

# UNSUPPORTED: Vulkan, Metal

# Unimplemented https://github.com/llvm/llvm-project/issues/108058
# XFAIL: Clang

# RUN: split-file %s %t
# RUN: %dxc_target -T cs_6_5 -Fo %t.o %t/source.hlsl
# RUN: %offloader %t/pipeline.yaml %t.o
