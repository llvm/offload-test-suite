#--- source.hlsl

// This test checks that we will get the expected values from invoking
// various `Load` and `Store` methods on `[RW]ByteAddressBuffer`.

// The expected behaviour is to load the values in `In0` and `In1` at the given
// byte-offset, add them, and store the result at the respective offset in
// `Out`.

struct ArrayStruct {
  int arr[4];
};

struct SmallStruct {
  int a;
  uint b;
};

struct LargeStruct {
  int4 a;
  int4 b;
  uint4 c;
  uint4 d;
};

ByteAddressBuffer In0 : register(t0);
ByteAddressBuffer In1 : register(t1);
RWByteAddressBuffer Out : register(u2);

[numthreads(4,1,1)]
void main() {
  // uint
  uint U0 = In0.Load(0);
  uint V0 = In1.Load(0);
  Out.Store(0, U0 + V0);

  uint2 U1 = In0.Load2(16);
  uint2 V1 = In1.Load2(16);
  Out.Store2(16, U1 + V1);

  uint3 U2 = In0.Load3(32);
  uint3 V2 = In1.Load3(32);
  Out.Store3(32, U2 + V2);

  uint4 U3 = In0.Load4(48);
  uint4 V3 = In1.Load4(48);
  Out.Store4(48, U3 + V3);

  // bool
  bool U4 = In0.Load<bool>(64);
  bool V4 = In1.Load<bool>(64);
  Out.Store<bool>(64, U4 + V4);

  bool2 U5 = In0.Load<bool2>(64);
  bool2 V5 = In1.Load<bool2>(64);
  Out.Store<bool2>(80, U5 + V5);

  bool3 U6 = In0.Load<bool3>(64);
  bool3 V6 = In1.Load<bool3>(64);
  Out.Store<bool3>(96, U6 + V6);

  bool4 U7 = In0.Load<bool4>(64);
  bool4 V7 = In1.Load<bool4>(64);
  Out.Store<bool4>(112, U7 + V7);

  // structs
  ArrayStruct U8 = In0.Load<ArrayStruct>(0);
  ArrayStruct V8 = In1.Load<ArrayStruct>(0);
  ArrayStruct TempStruct0;
  for(int I = 0; I < 4; I++) {
    TempStruct0.arr[I] = U8.arr[I] + V8.arr[I];
  }
  Out.Store<ArrayStruct>(128, TempStruct0);

  SmallStruct U9 = In0.Load<SmallStruct>(0);
  SmallStruct V9 = In1.Load<SmallStruct>(0);
  SmallStruct TempStruct1 = {U9.a + V9.a, U9.b + V9.b};
  Out.Store<SmallStruct>(144, TempStruct1);

  LargeStruct U10 = In0.Load<LargeStruct>(0);
  LargeStruct V10 = In1.Load<LargeStruct>(0);
  LargeStruct TempStruct2 = {U10.a + V10.a, U10.b + V10.b, U10.c + V10.c, U10.d + V10.d};
  Out.Store<LargeStruct>(160, TempStruct2);
}

//--- pipeline.yaml

---
Shaders:
  - Stage: Compute
    Entry: main
    DispatchSize: [4, 1, 1]
Buffers:
  - Name: In0
    Format: Int32
    Stride: 4
    Data: [ 1, 2, 3, 4, 5, 6, 7, 8, 
            9, 10, 11, 12, 13, 14, 15, 16,
            1, 0, 1, 0 ]
  - Name: In1
    Format: Hex32
    Stride: 4
    Data: [ 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 
            0x900, 0xA00, 0xB00, 0xC00, 0xD00, 0xE00, 0xF00, 0x1000,
            0x001, 0x000, 0x000, 0x001 ]
  - Name: Out
    Format: Hex32
    Stride: 4
    FillSize: 224
  - Name: ExpectedOut
    Format: Hex32
    Stride: 4
    Data: [ 0x101, 0x000, 0x000, 0x000, 0x505, 0x606, 0x000, 0x000,
            0x909, 0xA0A, 0xB0B, 0x000, 0xD0D, 0xE0E, 0xF0F, 0x1010,
            0x001, 0x000, 0x000, 0x000, 0x001, 0x000, 0x000, 0x000,
            0x001, 0x000, 0x001, 0x000, 0x001, 0x000, 0x001, 0x001,
            0x101, 0x202, 0x303, 0x404, 0x101, 0x202, 0x000, 0x000,
            0x101, 0x202, 0x303, 0x404, 0x505, 0x606, 0x707, 0x808,
            0x909, 0xA0A, 0xB0B, 0xC0C, 0xD0D, 0xE0E, 0xF0F, 0x1010 ]
Results:
  - Result: Test0
    Rule: BufferExact
    Actual: Out
    Expected: ExpectedOut
DescriptorSets:
  - Resources:
    - Name: In0
      Kind: ByteAddressBuffer
      DirectXBinding:
        Register: 0
        Space: 0
      VulkanBinding:
        Binding: 0
    - Name: In1
      Kind: ByteAddressBuffer
      DirectXBinding:
        Register: 1
        Space: 0
      VulkanBinding:
        Binding: 1
    - Name: Out
      Kind: RWByteAddressBuffer
      DirectXBinding:
        Register: 2
        Space: 0
      VulkanBinding:
        Binding: 2
...
#--- end

# Unimplemented https://github.com/llvm/llvm-project/issues/108058


# RUN: split-file %s %t
# RUN: %dxc_target -T cs_6_5 -Fo %t.o %t/source.hlsl
# RUN: %offloader %t/pipeline.yaml %t.o
